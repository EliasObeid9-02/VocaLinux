#import "../helpers.typ": ar, ar_std, en_clean, en_clean_std, en_std, en, ref

= #ar([الفصل الأول: مقدمة])

#ar_std([
  تعد واجهة سطر الأوامر في لينكس (#en_clean_std([CLI])) نموذجًا للقدرة والكفاءة في عالم الحوسبة. بالنسبة للمطورين ومسؤولي الأنظمة والمستخدمين المتمرسين، فهي البيئة المثالية للتحكم الدقيق في النظام، حيث توفر سرعة لا مثيل لها في أداء المهام المعقدة من خلال أوامر نصية موجزة. لكن هذه القوة تعتمد على افتراض مهم، وهو قدرة المستخدم على التفاعل مع لوحة المفاتيح بسرعة ودقة. هذا الاعتماد الأساسي على الكتابة اليدوية يخلق حاجزًا هائلاً، ويحول هذه الأداة الفعالة إلى مصدر إقصاء للعديد من الأفراد الماهرين.
])

== #ar([الحاجز الرقمي لسطر الأوامر])

#ar_std([
  في صميم هذا المشروع يوجد المستخدمون الذين لا يعتبرون لوحة المفاتيح العادية أداة للإنتاجية، بل عقبة. ويشمل ذلك الأفراد الذين يعانون من مجموعة من الإعاقات الحركية، مثل إصابات الإجهاد المتكرر (#en_clean_std([RSI])) والتهاب المفاصل والشلل، والتي يمكن أن تجعل الكتابة المطولة أو المعقدة مؤلمة أو بطيئة أو مستحيلة تمامًا.

  في حين أن واجهات المستخدم الرسومية الحديثة (#en_clean_std([GUIs])) قد حققت تقدمًا كبيرًا في مجال إمكانية الوصول، من خلال دمج ميزات مثل قارئات الشاشة، وأنماط التباين العالي، والتحكم الصوتي القوي، إلا أن بيئة سطر الأوامر ظلت إلى حد كبير بيئة متقشفة. وقد ظهرت فجوة حرجة في إمكانية الوصول: فالأداة التي توفر أعمق مستوى من التحكم في النظام هي الأقل ملاءمة لأولئك الذين لا يستطيعون استخدام لوحة المفاتيح. يتصدى هذا المشروع مباشرة لهذه الفجوة، ساعياً إلى سد الفجوة بين نية الإنسان وتنفيذ سطر الأوامر من خلال الصوت.
])

== #ar([بوابة صوتية إلى لينكس])

#ar_std([
  لمعالجة الفجوة التي تم تحديدها في إمكانية الوصول، يقترح هذا المشروع نظامًا مزدوج المكونات مصممًا ليكون بمثابة بوابة صوتية إلى #en_clean_std([Linux Shell]). تم تصميم الحل المقترح ليكون فعالاً وخفيف الوزن، مما يضمن قابليته للاستخدام عبر مجموعة واسعة من الأجهزة. وهذا لا يتطلب فقط مفسرًا متطورًا، بل يتطلب أيضًا مكونًا متخصصًا للغاية في التعرف على الكلام، ومضبوطًا بدقة ليتناسب مع الصيغة الفريدة لسطر الأوامر.

  يتكون النظام من وحدتين أساسيتين تعملان معًا:
  + *نظام التعرف على الكلام المعدل (#en_clean_std([ASR]))*: تتمثل مسؤولية هذه الوحدة في التقاط الكلمات المنطوقة من المستخدم وتحويلها إلى نص خام. يجب أن تكون مصممة خصيصًا للتعرف على المفردات وأنماط الصوتيات الخاصة بأوامر #en_clean_std([shell])، بما في ذلك القدرة على تمييز الأحرف الفردية لتهجئة المتغيرات.
  + *مترجم أوامر متخصص*: هذا هو جوهر المشروع المنطقي. يتلقى النص الخام من نظام #en_clean_std([ASR]) ويقوم بعدة مهام حاسمة: يربط النص غير المنظم بأمر صالح، ويتحقق من الأخطاء النحوية، ويصحح الأخطاء الإملائية الشائعة، ويبني مسارات ملفات سليمة بذكاء من كلام المستخدم.

  أحد مبادئ التصميم الأساسية هو الكفاءة في استخدام الموارد. ولهذا السبب، تم استبعاد استخدام نماذج اللغة الكبيرة (#en_clean_std([LLMs])) بشكل صريح. على الرغم من قوتها، فإن نماذج اللغة الكبيرة تتطلب موارد حاسوبية ومتطلبات أجهزة كبيرة تتعارض مع هدف إنشاء أداة قابلة للاستخدام على نطاق واسع.
])

== #ar([الأهداف والغايات])

#ar_std([
  الهدف الأساسي من هذا المشروع هو تصميم وتنفيذ وتقييم نظام نموذجي يوفر واجهة صوتية لا تحتاج إلى استخدام اليدين لبرنامج #en_clean_std([Linux shell])، مع التركيز على تحسين إمكانية الوصول للمستخدمين ذوي الإعاقات الجسدية.

  لتحقيق هذا الهدف، تم تحديد الأهداف التالية:
  + تحديد نموذج مناسب للتعرف التلقائي على الكلام (#en_clean_std([ASR])) يكون خفيف الوزن وقويًا وقادرًا على التعرف المستقل على الأحرف.
  + تدريب وتعديل نموذج ASR المحدد لتحسين أدائه ودقته بشكل خاص لنسخ أوامر #en_clean_std([Linux shell]).
  + تصميم بنية نظام تدمج بشكل فعال وحدة #en_clean_std([ASR]) المعدلة مع محرك تفسير أوامر مخصص.
  + تطوير نموذج أولي عملي يمكنه التعرف على مجموعة أساسية من أوامر لينكس الشائعة وصياغتها بشكل صحيح.
  + تقييم دقة النموذج الأولي وقابليته للاستخدام بناءً على مجموعة محددة مسبقًا من سيناريوهات الأوامر الصوتية.
])

== #ar([المجال والقيود])

#ar_std([
   لضمان إمكانية إنجاز المشروع في الإطار الزمني المحدد، تم تحديد نطاقه بعناية. سيركز المشروع حصريًا على بيئة العمل البرمجية `bash`، واللغة الإنجليزية، ومجموعة مختارة من الأوامر من حزمة #en_clean_std([GNU]) `coreutils`.

  *الأوامر ضمن المجال*:
  #align(center+top, grid(
      rows: (1.5em, 1.5em, 1.5em),
      columns: (1fr, 1fr, 1fr),
      `ls`,    `cd`,   `cp`,
      `mv`,    `rm`,   `mkdir`,
      `rmdir`, `echo`, `touch`,
    )
  )

  على الرغم من أن هذا المشروع لن ينشئ محركًا للتعرف على الكلام من الصفر، فإن جزءًا كبيرًا من العمل يتضمن اختيار وتعديل وضبط نموذج #en_clean_std([ASR]) موجود بالفعل لتلبية المتطلبات المحددة لكتابة الأوامر. لن يدعم النظام، في نسخته الأولية، ميزات #en_clean_std([shell]) المتقدمة مثل تسلسل الأوامر (piping) أو إعادة التوجيه أو تنفيذ برامج #en_clean_std([shell]) النصية. تمت الإشارة إلى هذه المجالات باعتبارها مجالات محتملة للعمل في المستقبل.
])

== #ar([الأبحاث المرجعية])

#ar_std([
  يعتمد هذا المشروع على الأسس التي وضعتها العديد من الأوراق البحثية الهامة في مجال التعرف على الكلام والتعلم العميق. توفر الأوراق التالية الأساس النظري والعملي للمكونات الأساسية لنظامنا.
])

=== #en_clean([Listen, Attend, and Spell])

#ar_std([
  تقدم هذه الورقة نموذج #en_clean_std([Listen, Attend, and Spell (LAS)])، وهو شبكة عصبية شاملة للتعرف التلقائي على الكلام. وتقترح بنية جديدة تتكون من #en_clean_std([\"Listener\"]) (مشفر) يعالج المدخلات الصوتية و #en_clean_std([\"Speller\"]) (مفكك) يستخدم آلية الانتباه لتوليد النص المكتوب. يبسط نموذج #en_clean_std([LAS]) عملية التعرف على الكلام التقليدية من خلال تعلم تدوين الكلام مباشرة من الصوت، وهو جوهر مكون تحويل الكلام إلى نص لدينا. #ref("1")
])

=== #en_clean([Attention is All You Need])

#ar_std([
  تقدم هذه الورقة البحثية الرائدة بنية #en_clean_std([Transformer])، التي تستغني تمامًا عن التكرار والالتواءات، وتعتمد فقط على آليات الانتباه. على الرغم من عدم استخدام نموذج #en_clean_std([Transformer]) الكامل في هذا المشروع، فإننا نستفيد من ابتكاره الرئيسي: #en_clean_std([Multi-Head Attention]). تعزز هذه الآلية الانتباه القياسي من خلال تشغيله عدة مرات بالتوازي. يتعلم كل من ”رؤوس الانتباه“ هذه التركيز على أجزاء مختلفة من المدخلات، مما يسمح للنموذج بالاهتمام بشكل مشترك بالمعلومات من فضاءات تمثيلية فرعية مختلفة في وقت واحد. يتم الاستفادة من هذا المفهوم لتحسين قوة التمثيل لطبقة الانتباه في نموذجنا. #ref("2")
])

=== #en_clean([Attention-Based Models for Speech Recognition])

#ar_std([
  تستكشف هذه الورقة بشكل أعمق استخدام آليات الانتباه في التعرف على الكلام. وهي تقدم آلية انتباه مدركة للموقع تساعد النموذج على التعامل بشكل أفضل مع العبارات الطويلة والتكرارات. وهذا أمر مهم بشكل خاص لمشروعنا، لأنه يسمح للنموذج بالحفاظ على التركيز على الأجزاء ذات الصلة من الإشارة الصوتية عند نسخ أوامر أطول وأكثر تعقيدًا. #ref("3")
])

=== #en_clean([SpecAugment: A Simple Data Augmentation Method])

#ar_std([
  يقدم #en_clean_std([SpecAugment]) تقنية بسيطة ولكنها فعالة للغاية لتعديل البيانات من أجل التعرف على الكلام. تعمل هذه التقنية مباشرة على مخطط الطيف الصوتي #en_clean_std([log-mel]) للمدخلات الصوتية، وتطبق تقنية تشويه الزمن وإخفاء التردد وإخفاء الزمن لإنشاء نماذج أكثر قوة. من خلال دمج #en_clean_std([SpecAugment]) في مسار التدريب لدينا، نهدف إلى تحسين مرونة النموذج في التعامل مع الاختلافات في الكلام وضوضاء الخلفية. #ref("4")
])

=== #en_clean([Scheduled Sampling for Sequence Prediction])

#ar_std([
  تتناول هذه الورقة مشكلة شائعة في تدريب نماذج تنبؤ السلاسل: التباين بين التدريب (باستخدام #en_clean_std([\"teacher forcing\"])) والاستدلال (باستخدام تنبؤات النموذج نفسه). يوفر #en_clean_std([Scheduled Sampling]) استراتيجية تعليمية منهجية تنتقل تدريجياً من #en_clean_std([teacher forcing]) إلى استخدام تنبؤات النموذج نفسه أثناء التدريب. وهذا يساعد على سد الفجوة بين التدريب والاستدلال، مما يؤدي إلى أداء أفضل في سيناريوهات العالم الحقيقي. #ref("5")
])

=== #en_clean([Cyclical Learning Rates for Training Neural Networks])

#ar_std([
  تتحدى هذه الورقة الفكرة السائدة المتمثلة في خفض معدل التعلم بشكل رتيب. وتقترح معدلات التعلم الدورية (#en_clean_std([CLR]))، وهي طريقة يتغير فيها معدل التعلم بشكل دوري بين الحد الأدنى والحد الأقصى. يمكن أن تؤدي هذه التقنية إلى تدريب أسرع وأداء محسّن من خلال مساعدة النموذج على اجتياز نقاط الوسط في منحنى الخسارة بشكل أكثر فعالية. يشكل هذا المفهوم الأساس لاستراتيجية تحسين متقدمة تم استكشافها في المراحل اللاحقة من تدريب نموذجنا. #ref("6")
])   


== #ar([هيكل التوثيق])

#ar_std([
  تم تصميم التوثيق لتقديم نظرة عامة شاملة على المشروع. يتعمق الفصل الثاني في الأسس النظرية للتقنيات المستخدمة، بما في ذلك نموذج #en_std([LAS]). يقدم الفصل الثالث تفاصيل تصميم النظام وتنفيذه، بما في ذلك الهندسة المعمارية وتدريب النموذج وتكامل المكونات.
])

#pagebreak()
